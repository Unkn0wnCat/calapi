package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"errors"
	"fmt"
	"github.com/Unkn0wnCat/calapi/internal/database"
	"github.com/Unkn0wnCat/calapi/internal/db_model"
	"github.com/objectbox/objectbox-go/objectbox"
	"strconv"
	"time"

	"github.com/Unkn0wnCat/calapi/graph/model"
)

// Events is the resolver for the events field.
func (r *calendarResolver) Events(ctx context.Context, obj *model.Calendar, after *time.Time, before *time.Time) ([]*model.Event, error) {
	if after == nil {
		now := time.Now()
		after = &now
	}
	if before == nil {
		oneYearLater := time.Now().Add(time.Hour * 24 * 365)
		before = &oneYearLater
	}

	eventBox := db_model.BoxForEvent(database.ObjectBox)

	filters := []objectbox.Condition{db_model.Event_.Start.Between(after.UnixMilli(), before.UnixMilli())}

	filters = append(filters, db_model.Event_.Calendar.In(obj.DbID))

	query := eventBox.Query(filters...)
	results, err := query.Find()
	if err != nil {
		return nil, err
	}

	events := make([]*model.Event, len(results))

	for i, result := range results {
		event := model.FromEvent(*result)
		events[i] = &event
	}

	return events, nil
}

// Calendar is the resolver for the calendar field.
func (r *eventResolver) Calendar(ctx context.Context, obj *model.Event) (*model.Calendar, error) {
	modelCalendar := model.FromCalendar(*obj.DbCalendar)

	return &modelCalendar, nil
}

// CreateEvent is the resolver for the createEvent field.
func (r *mutationResolver) CreateEvent(ctx context.Context, input model.NewEvent) (*model.Event, error) {
	panic(fmt.Errorf("not implemented: CreateEvent - createEvent"))
}

// EditEvent is the resolver for the editEvent field.
func (r *mutationResolver) EditEvent(ctx context.Context, input model.EditEvent) (*model.Event, error) {
	panic(fmt.Errorf("not implemented: EditEvent - editEvent"))
}

// DeleteEvent is the resolver for the deleteEvent field.
func (r *mutationResolver) DeleteEvent(ctx context.Context, input string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteEvent - deleteEvent"))
}

// CreateCalendar is the resolver for the createCalendar field.
func (r *mutationResolver) CreateCalendar(ctx context.Context, input model.NewCalendar) (*model.Calendar, error) {
	panic(fmt.Errorf("not implemented: CreateCalendar - createCalendar"))
}

// EditCalendar is the resolver for the editCalendar field.
func (r *mutationResolver) EditCalendar(ctx context.Context, input model.EditCalendar) (*model.Calendar, error) {
	panic(fmt.Errorf("not implemented: EditCalendar - editCalendar"))
}

// DeleteCalendar is the resolver for the deleteCalendar field.
func (r *mutationResolver) DeleteCalendar(ctx context.Context, input string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteCalendar - deleteCalendar"))
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context, after *time.Time, before *time.Time, calendar *string) ([]*model.Event, error) {
	if after == nil {
		now := time.Now()
		after = &now
	}
	if before == nil {
		oneYearLater := time.Now().Add(time.Hour * 24 * 365)
		before = &oneYearLater
	}

	eventBox := db_model.BoxForEvent(database.ObjectBox)

	filters := []objectbox.Condition{db_model.Event_.Start.Between(after.UnixMilli(), before.UnixMilli())}

	if calendar != nil {
		calendarId, err := strconv.ParseUint(*calendar, 16, 64)
		if err != nil {
			return nil, err
		}

		filters = append(filters, db_model.Event_.Calendar.In(calendarId))
	}

	query := eventBox.Query(filters...)
	results, err := query.Find()
	if err != nil {
		return nil, err
	}

	events := make([]*model.Event, len(results))

	for i, result := range results {
		event := model.FromEvent(*result)
		events[i] = &event
	}

	return events, nil
}

// Calendars is the resolver for the calendars field.
func (r *queryResolver) Calendars(ctx context.Context) ([]*model.Calendar, error) {
	calendarBox := db_model.BoxForCalendar(database.ObjectBox)
	results, err := calendarBox.GetAll()
	if err != nil {
		return nil, err
	}

	calendars := make([]*model.Calendar, len(results))

	for i, result := range results {
		calendar := model.FromCalendar(*result)
		calendars[i] = &calendar
	}

	return calendars, nil
}

// Calendar is the resolver for the calendar field.
func (r *queryResolver) Calendar(ctx context.Context, id string) (*model.Calendar, error) {
	actualId, err := strconv.ParseUint(id, 16, 64)
	if err != nil {
		return nil, err
	}

	calendarBox := db_model.BoxForCalendar(database.ObjectBox)
	calendar, err := calendarBox.Get(actualId)
	if err != nil {
		return nil, err
	}

	if calendar == nil {
		return nil, errors.New("not found")
	}

	modelCalendar := model.FromCalendar(*calendar)
	return &modelCalendar, nil
}

// Event is the resolver for the event field.
func (r *queryResolver) Event(ctx context.Context, id string) (*model.Event, error) {
	actualId, err := strconv.ParseUint(id, 16, 64)
	if err != nil {
		return nil, err
	}

	eventBox := db_model.BoxForEvent(database.ObjectBox)
	event, err := eventBox.Get(actualId)
	if err != nil {
		return nil, err
	}

	if event == nil {
		return nil, errors.New("not found")
	}

	modelEvent := model.FromEvent(*event)
	return &modelEvent, nil
}

// Calendar returns CalendarResolver implementation.
func (r *Resolver) Calendar() CalendarResolver { return &calendarResolver{r} }

// Event returns EventResolver implementation.
func (r *Resolver) Event() EventResolver { return &eventResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type calendarResolver struct{ *Resolver }
type eventResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
